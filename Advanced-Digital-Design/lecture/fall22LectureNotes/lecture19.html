<head>
<!DOCTYPE html>
<html lang="en">
<!----- http://getbootstrap.com/css/ ----->
    <head>
        <title>ECE 383 - Lecture Notes</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="ECE 383- Embedded Systems II">
        <meta name="author" content="Chris Coulston">
        <link rel='stylesheet' type='text/css' href='//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css'>
        <script src='//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js'></script>
    </head>

<body>
        <div class = "container">
            <div class = "navbar navbar-inverse">
                <div class = "navbar-inner">
                    <a class = "brand" href="../index.html">ECE 383</a>
                    <ul class="nav pull-right">
                        <li><a href="./lecture18.html">&ltPrev</a></li>
                        <li><a href="./lecture23.html">Next&gt</a></li>
                    </ul>
                </div>
            </div>

<table class="table table-striped table-bordered table-condensed">
<tr><td>Date:</td>	<td>February 22</td></tr>
<tr><td>Lecture:</td>	<td>19</td></tr>
<tr><td>Homework	<td><a href="../hw/hw11.html">HW #11</a></td></tr>
<tr><td>Status		<td bgcolor = #D0FFD0>Complete
<tr><td>Code		<td><a href="./code/lec19.c">lec19.c</a></td></tr>
<tr><td>Tech Docs	
<td><a href="http://www.xilinx.com/support/documentation/sw_manuals/xilinx11/oslib_rm.pdf">OS and Libraries Document Collection</a><br>
<a href="http://www.xilinx.com/support/documentation/sw_manuals/mb_ref_guide.pdf">MicroBlaze Processor Reference Guide</a><br></td></tr>
</table>


<h2>Interrupts</h2>
Interrupts are used when you want to your system to do more than one
thing at a time.  An interrupt service routine (ISR) is a subroutine
called by hardware.  The following figure illustrates the process of
"calling" and returning from an ISR.

<br><img src="./img/lecture19-3.gif"><br><br>

<ol>	<li>MCU powers up, jumps to RESET vector
	<li>MCU starts execution of main
	<li>Dynamic configuration
	<ul>	<li>configure hardware
		<li>clear hardware interrupt flag
		<li>enable hardware interrupt</ul>
	<li>Event occurs which sets interrupt flag
	<li>MCU stops running main
	<li>MCU saves PC
	<li>MCU disables interrupts
	<li>Executes "GOTO ISR" at interrupt vector address
	<li>ISR: Poll interrupt flags
	<li>ISR: Execute appropriate code in ISR
	<li>ISR: Clear interrupt flag
	<li>ISR: executes rted 
	<li>Interrupts are enabled
	<li>PC is restored
	<li>MCU resumes running main
</ol>


<h2>Interrupts in the microBlaze</h2>
Today we will examine how to generate an interrupt into the 
microBlaze.  This will require three ideas to come together.
First, hardware to generate an interrupt.  For the example
today we'll be using the counter from hw10 to generate an 
interrupt in the microBlaze.  We will have to understand
how to route the roll signal to the microBlaze.
Second, we will need to configure
the EDK tool to recognize the roll signal as an interrupt.  This
will require configuring the system.mhs file.
Third, we will need to understand how to write our C code
to respond to the interrupt signal generated by our counter.

<h2>Modify the counter</h2>
In HW#10 you modified the counter to assert the roll signal
when the count is at the maximum value. For the sake of this 
lecture, we will assume that you put your HW#10 solution in
a file called lec19.vhd.  The roll signal must
be sent to the microBlaze by routing it through both the 
user_logic and counter interfaces.  This is illustrated in the 
following figure.
<br><img src="./img/lecture19-2.gif"><br><br>

You should notice that the roll signal will go through all the
same interfaces as the LED signal.  The important distinction is
that the roll signal will not be output from the Spartan chip and
as a consequence, the roll signal will NOT appear in the system.ucf
file.  Instead it is routed to the microBlaze in the following step.

<h2>Configure the interrupt signal</h2>
Next add the roll signal to the counter.mpd file.  Note that
this is unusual, because we have no intention of sending the
roll signal outside the Spartan 6 chip - every other signal in
the MPD file is being sent off chip.  We will need this modification
to make the roll signal visible to the next step.

<pre>
    PORT roll = "", DIR = O
</pre>

Make sure to save and close this MPD file. Then hit the 
Rescan the User IP Repositories button before moving to the next step.  
Open your  &ltprojectName&gt.mhs file and and find the configuration block
for your counter.  If it does not have the following line, then add it
<pre>
    PORT roll = counter_0_roll
</pre>

Note that the name "counter_0_roll" will need to agree with the name
of the roll signal in your counter instance in the the System Assembly 
View, Port tab.
<br>

Now continue scrolling through the &ltprojectName&gt.mhs file, looking 
for the microBlaze block.  Add the following line to the end of this
block (just before the END).
<pre>
    PORT interrupt = counter_0_roll
</pre>

Save and exit the mhs file.  Back in the System Assembly View, Ports
tab (as shown below at left), you may need to click in the red circled
area and select external for the roll signal.  More than likely 
it will already be labeled as an interrupt as shown at right in the
figure below.

<br><img src="./img/lecture19-1.gif"><br><br>

You are now ready to program this new piece of hardware.  So
Generate BitStream and then EXport Design.


<h2>C programming</h2>

In order to understand how interrupts are handled by the microBlaze, its
important to understand something about the hardware.  I found most of the
following information in the microBlaze Users Guide.

<ul>
<li>The Machine Status Register contains control and status bits for the processor.
Bit 30 of this register, IE, is the interrupt enable.
<li>The microBlaze is a three stage pipeline machine - interrupts will
need to flush the pipe before proceeding.
<li>The interrupt vector is located at address 0x10-0x14 in memory.
<li>microBlaze supports a single interrupt source.
<li>When an interrupt occurs, the following actions happen.
<pre>
r14 <- PC
PC <- 0x00000010
MSR[IE] <- 0
</pre>
<li>When the interrupt service routine terminates, control is turned over 
to the instruction at address r14 and MSR[IE] is set.
</ul>





<pre>
//--------------------------------------------------------------------
//-- Name:	Chris Coulston
//-------------------------------------------------------------------------
#include <xil_exception.h>

void myISR(void);

int main(void) {

    microblaze_register_handler((XInterruptHandler) myISR, (void *) 0);
    microblaze_enable_interrupts();
            	
    stuff();

} // end main


void myISR(void) {
	isrCount = isrCount + 1;
}
</pre>


There may be occasion for you to examine the compiled assembly language for
the microBlaze.  To do this open the lec19.o file located in your project folder
Debug -> src -> lec19.o  You will find the 
<a href="http://www.xilinx.com/support/documentation/sw_manuals/mb_ref_guide.pdf">
MicroBlaze Processor Reference Guide</a> handy to interpret the instructions.

<h3>Manual Easter-egg Hunt</h3>
Consult the MicroBlaze Processor Reference Guide and convert the
<ul>	<li>addik r22,r19,1
	<li>swi r23, r1, 60
	<li>bgei r18, -44
</ul>

<!-------
addik r22, r19, 1	addik rD, rA, IMM
Helpful:	22 = 10110
Helpful:	19 = 10011
machine:	001KC0 rD rA IMM
binary:		0010_0010_1101_0011_0000_0000_0000_0001
hex:		32D30001

swi r23, r1, 60		swi rD, rA, IMM
Helpful:	23 = 10111
		60 = 0011_1100
machine:	111110 rD rA IMM
binary:		1111_1010_1110_0001_0000_0000_0011_1100
hex		FAE1003E

bgei r18, -44		bgei rA, IMM
Helpful:	18 = 10010
		-44 = FFD4 (16-bit 2's)
machine:	101111 D0101 rA IMM
binary:		1011_1100_1011_0010_1111_1111_1101_0100
hex:		BCB2FFD4
---->

Consult the <a href="http://www.xilinx.com/support/documentation/sw_manuals/xilinx11/oslib_rm.pdf">OS and Libraries Document Collection</a>.
<ol>
<li>What string formats are supported by the xil_print instruction?
</ol>


</body>
</html>
