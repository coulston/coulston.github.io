
<head>
<!DOCTYPE html>
<html lang="en">
<!----- http://getbootstrap.com/css/ ----->
    <head>
        <title>ECE 383 - Lecture Notes</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="ECE 383- Embedded Systems II">
        <meta name="author" content="Chris Coulston">
        <link rel='stylesheet' type='text/css' href='//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css'>
        <script src='//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js'></script>
    </head>

<body>
        <div class = "container">
            <div class = "navbar navbar-inverse">
                <div class = "navbar-inner">
                    <a class = "brand" href="../index.html">ECE 383</a>
                    <ul class="nav pull-right">
                        <li><a href="./lecture04.html">&ltPrev</a></li>
                        <li><a href="./lecture09.html">Next&gt</a></li>
                    </ul>

                    </ul>
                </div>
            </div>

<table class="table table-striped table-bordered table-condensed">
<tr><td>Date:</td>	<td>January  15</td></tr>
<tr><td>Lecture:</td>	<td>5</td></tr>
<tr><td>Next lecture	<td><a href="../hw/hw5.html">HW5</a>
<tr><td>Status		<td bgcolor = #D0FFD0>Complete
<tr><td>Handout		<td><a href="../hand/hand05.docx">hand05.docx</a>
<tr><td>Code		<td>	<a href="./code/lec05.vhdl">lec05.vhdl</a><br>
				<a href="./code/lec05.ucf">lec05.ucf</a>
</table>


<h2>Comparator construction</h2>
In the upcoming lab you will need to generate a signal that behaves according
to the following CSA statement.

<pre>
	h_synch <= '1' when ((h_count >= 100) and (h_synch < 200)) else '0';
</pre>

However, if you implemented the h_synch signal using this method (non-gated 
output), your circuit would not behave correctly.  The fundamental problem
is that <b>non-gated signals generate glitches on their output.</b>  These
glitches are generated by the comparators inherent in the CSA above.  To
understand this problem and its solution will require some discussion, so lets
get started.<br><br>


Large comparators are built using the method employed to determine the relative 
magnitude of two numbers X and Y.  To accomplish this you work from the most to 
least significant bits. At each step, compare a bit of X
and Y . If the bits are equal, then continue to the next least significant bit.
Otherwise, either X or Y is larger, and the comparison is over.  In this way
the validity of the output ripples from the most to the least significant bit.
Since real logic gates have delay, there is a delay to get a valid bit.  This
delay is the focus of this lecture.

<h2>Gated and non-gates circuit</h2>
In the upcoming lab you will have to design a circuit to output 2 signals crucial to the
proper operation of the VGA display.  In order for these outputs to properly drive the 
display they need to be both glitch free and promptly available after a clock edge.  This
requires that the outputs be gated - they must be output from flip flops, not combinational
logic.  In order to demonstrate the potential pitfalls of combinational logic, I coded-up
lec05.vhdl (linked at the top of this page).  


<br><img src="./img/lecture05-2.gif"><br><br>

The outputs from the two processing block depends on the value of the counter's output
(processQ) compared to one of three constants L0, L1, L2 (set inside lec05.vhdl). Both
the gates and non-gate circuit have the same relationship between processQ and output JB.
The difference is how this is accomplished; the table below illustrates.


<table border=1>

<tr><td>Combinational Realization<br>Non-gated</td>	<td>Sequential Realization<br>Gated</td></tr>
<tr><td valign="top" halign="left">
<pre>					
	JB(3 downto 0) <= "0001" when ((processQ >= 0) and (processQ < L0)) else
			  "0010" when ((processQ >= L0) and (processQ < L1)) else
			  "0100" when ((processQ >= L1) and (processQ < L2)) else
			  "1000";
</pre></td>

<td valign="top" halign="left">
<pre>					
	process(clk)
	begin
	    if (rising_edge(clk)) then
		if (reset = '0') then
		    JB(6 downto 4) <= "000";
		elsif ((processQ >= 0) and (processQ < L0)) then
		    JB(6 downto 4) <= "001";
		elsif ((processQ >= L0) and (processQ < L1)) then
		    JB(6 downto 4) <= "010";
		elsif ((processQ >= L1) and (processQ < L2)) then
		    JB(6 downto 4) <= "100";
		elsif (processQ >= L2) then
		    JB(6 downto 4) <= "111";
		end if;
	    end if;
	end process;
</pre></td></tr>

</table>


At first glance you would not be faulted for thinking that these two circuits have
identical outputs.  Theoretically, they do, but reality has a cruel surprise in the
the form of glitches.  If you connect an oscilloscope up to the PMOD connector (see
page 21 of the Atlys Board Reference Manual) corresponding to JB(3) and JB(2) (the 
most 2 significant bits of the non-gated comparator outputs) you would see the 
trace below.

<br><img src="./img/lecture05-1.gif"><br><br>

You should notice that the output is not entirely smooth in areas between the edges.
These discontinuities illustrate the fact that the comparator is built from bit-slice
comparators and as a consequence the output is generated by rippling a signal from
the most significant bit of the comparator to the least.  This allows the output to
temporarily assume an incorrect output until the rippling output reaches the least
significant bit.  While the discontinuities look small, this is only the portion of
the signal that has reached the output pin of the FPGA.  Internally the glitches
have a much larger magnitude.

<h3>Buttons</h3>
You should notice that the counter only counts with btn(4) = '0'.  A quick glance
at the silk screen on the Atlys board will confirm that this is the center button
in the 4-way pad on the lower right of the board.  The buttons are nominally logic
0, meaning that when they are not pressed they are at logic 0.  When pressed the 
button go to logic 1.

</html>
