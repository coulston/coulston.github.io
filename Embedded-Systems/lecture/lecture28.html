<!DOCTYPE html>
<html lang="en">
<!----- http://getbootstrap.com/css/ ----->
    <head>
        <title>EENG 383 - Lecture Notes</title>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="EENG 383 - Microcomputer Architecture and Interfacing">
        <meta name="author" content="Chris Coulston">
        <link rel='stylesheet' type='text/css' href='//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/css/bootstrap-combined.min.css'>
        <script src='//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js'></script>
    </head>

<body>
        <div class = "container">
            <div class = "navbar navbar-inverse">
                <div class = "navbar-inner">
                    <a class = "brand" href="../index.html">EENG 383</a>
                    <ul class = "nav">
                        <li><a href="../index.html">Home</a></li>
                    </ul>
                    <ul class="nav pull-right">
                        <li><a href="./lecture27.html">&ltPrev</a></li>
                        <li><a href="./lecture29.html">Next&gt</a></li>
                    </ul>
                </div>
            </div>

<table class="table table-striped table-bordered table-condensed">
<tr><td>Lecture:</td>   <td>28</td></tr>
<tr><td>Objective:	<td>To introduce the concept of direct digital
	synthesis and use it to motivate the introduction of fixed 
	point numbers.
</table>


<h2>DDS</h2>
According to 
<a href="http://www.analog.com/media/en/training-seminars/tutorials/MT-085.pdf">Analog Devices MT-085 tutorial</a>, direct digital synthesis (DDS) is "... a
digitally-controlled method of generating multiple frequencies from a
reference frequency source..."  In other words, DDS is a technique that
allows you to produce some periodic waveform with a finely adjustable 
frequency.  This lecture will focus on generating sine waves, but you can
generate any periodic waveform.  Understanding the hardware structure of 
a DDS system, shown below, will help you understand how to design one
in software.

<br><img src="./img/dds.gif"><br><br>

The clock source shown in this figure is the <u>update rate</u> of the DDS 
system and is entirely determined by your software.   Every clock period, 
the Phase accumulator (a counter) is incremented by the value contained
in the Phase register (a register).  We will call the value stored in the
Phase register the <u>phase increment</u>.  By changing the phase increment,
you change the frequency of the waveform generated by the DDS system.  The 
integer part (more on this later) of the Phase accumulator output is used
as the address to a ROM containing your waveform. The ROM contains a digitized
version of your periodic waveform.  In our diagram, the stored values of a 
sinusoid are shown in orange.  An example of a 16-entry ROM given as a 
C-code snippet is shown below.
<pre>
uint8_t sin[N] = {128	,153	,177	,199	,219	,234	,246	,254	,255	,254	,246	,234	,219	,199	,177	,153	,128	,103	,79	,57	,37	,22	,10	,2	,0	,2	,10	,22	,37	,57	,79	,103};
</pre>

Notice that the amplitude of the sine wave starts at 128 and does not finish
at 128.  That is the sine wave does not complete a full wave, instead it ends 
at 103, one value short of completing a full wave.  This is important 
because the Phase accumulator will roll-over from 15 to 0, thus forming a
correct transistion from 103 (the end of one wave) to 128 (the start of
the next sine wave).<br><br>

If we filled the DDS ROM with the 16 entries for the sine wave defined above,
the address for the ROM would be 4-bit bits wide, generating addresses 
between 0 and 15.  Also the ROM would be 8-bits wide so that it could 
accommodate the range of values between 0 - 255.  The output from the ROM 
is feed into a duty cycle register (PWMDTY) of the PWM subsystem.  The 
output PWM waveform is sent to a low pass filter (LPF) which averages the
PWM waveform.  This means that a 3.3V PWM waveform with a 20% duty cycle will
have a LPF output of 20% of 3.3V or 0.2*3.3V = 0.66V.

<br><img src="./img/pwm2DC.bmp"><br><br>

This produces a reasonably good analog value.  Now to the DDS algorithm
strings together a series of these analog values to produce an analog
waveform as shown in the image below.  

<br><img src="./img/pwm2AC.bmp"><br><br>

Now let's take a look at the math that relates the phase increment to the
frequency of the output waveform.

<h3>Phase Increment</h3>
Lets say that the update rate was 10us and the phase increment was 1.  This
means that every 10us, the address to the ROM would increase by 1.  It
follows that it would take 64*10us = 640us to go from the start (address 0)
to the end (address 63) of the ROM.  In those 640us you would generate 1
wave of the sinusoid.  The recirorical of 640us/1 wave is 1,563 waves per
second or 1.563kHz.<br>


Now let's change the phase increment to 2 while leaving the update rate 
alone.  Now it would only take you 32*10us = 320us to go from the start to
the end of the ROM.  Thus the period of the wave would be 320us or a
frequency of 3.125kHz.
Since we will be working with more complex calculations in a minute, let's
use dimensional analysis to arrive at this result.
<br><br>

<pre>
    1 update   10^6 us   2 phase inc      1 wave       3,125 waves
    -------- * ------- * ----------- * ------------- = ----------- 
      10us      1 sec     1 update      64 phase inc     second
</pre>

For the time being we will allow fractional phase increments and 
fractional values for the phase accumulator.  In this case you can
assume that the output of the phase accumulator is truncated to an
integer before being used as the address to the ROM.  We will 
return to this assumption later and see how this can be accomplished
in hardware.

<br>
<br>

<b>Problem:</b><br>
Given: A DDS system with an update rate of 10us, a 64 entry ROM, and
a phase increment of 1.92.  Find the frequency of the output waveform.
<br><br>

<b>Answer:</b><br>
<pre>
 1 update   10^6 us   1.92 phase inc      1 wave    
 -------- * ------- * -------------- * ------------  = 3kHz
    10us      1s         1 update      64 phase inc  
</pre>

<b>Problem:</b><br>
Given: A DDS system with an update rate of 10us, a 64 entry ROM.
Find the phase increment to generate a 8.5kHz wave.
<br><Br>

<b>Answer:</b><br>
<pre>
 1 update   10^6 us   X phase inc     1 wave    
 -------- * ------- * ----------- * -----------  = 8.5kHz
    10us     1s         1 update    64 phase inc  
</pre>

Solving yields X = 5.44<br><Br>


Using integer values for the phase increment and phase accumulator would
be very limiting.  We need a way to allow fractional values for these 
two quantities.  You can accomplish this by using fixed-point mathematics.
<br><br>


<h2>Fixed Point</h2>
Binary numbering is a positional numbering system: the position
of a digit determines its magnitude in the resulting value.
In a positional number system every digit is given an index,
describing the position of the digit in the number.  The digit
immediately to the left of the decimal point has index 0.  Index
increases (by consecutive integers) to the left and decreases
(by consecutive integers) to the right.  Thus, to the
right of the decimal point the digits have a negative index.
The <b>value</b> of a number is the result of putting the digits
of a number into the equation:<br>
<center>        value = sum (d<sub>i</sub> * base <sup> index</sup>)</center>
<br>
where the base of the numbering system is the number of allowed
digits (e.g. the binary base is 2 since it can take on two values: 0 and 1).  
The following power of 2 table should help you in your conversions.
<br><br>

<table class="table table-striped table-bordered table-condensed">
<tr><td>Index	<td>weight
<tr><td>7	<td>128
<tr><td>6	<td>64
<tr><td>5	<td>32
<tr><td>4	<td>16
<tr><td>3	<td>8
<tr><td>2	<td>4
<tr><td>1	<td>2
<tr><td>0	<td>1
<tr><td>-1	<td>0.5
<tr><td>-2	<td>0.25
<tr><td>-3	<td>0.125
<tr><td>-4	<td>0.0625
<tr><td>-5	<td>0.03125
<tr><td>-6	<td>0.015625
<tr><td>-7	<td>0.0078125
<tr><td>-8	<td>0.00390625
</table>

When representing fixed point values  using binary, we will not explicitly 
write the decimal point. Instead we will come to an agreement where the 
decimal point goes before-hand using dot notation.  A fixed point value
with N integer bits and M fractional bits will be described as a "N.M
format number"  For example, say you wanted to represent the decimal 
value 6.75 as a 4.4 format number.  You know that 6 = (0110)<sub>2</sub>
and that 0.75 = 2<sup>-1</sup> + 2<sup>-2</sup> = (0.11)<sub>2</sub>.
So as a 4.4 format number, 6.75 = 0110.1100<br><br>  We will have a 
strong preference for N.M format numbers where N+M is 8, 16, or 32 because
these numbers will fit into our standard data-type sizes.  
Now let's do some fixed point conversions to test our understanding.
<br><br>

<b>Question:</b><br>
What value does 01001010 equal when interpreted as a 6.2 format number?
<br><br>

<b>Answer:</b><br>
For the sake of deriving an answer, I'll explicitly represent the
decimal point format in the binary representation as 010010.10  The 
whole number portion is (010010)<sub>2</sub> = 18 in decimal.  The binary 
fraction is (0.10)<sub>2</sub> which is 0.5 decimal.  So when you interpret
0b0100 1010 as a 6.2 format number its value is 18.5<br><br>

<b>Question:</b><br>
What value does 01001010 equal when interpreted as a 2.6 format number?
<br><br>

<b>Answer:</b><br>
For the sake of deriving an answer, I'll explicitly represent the
decimal point format in the binary representation as 01.001010  The 
whole number portion is (01)<sub>2</sub> = 1 in decimal.  The binary 
fraction is (0.001010)<sub>2</sub> which is 0.15625 decimal.  So when you
interpret 0b0100 1010 as a 2.6 format number its value
is 1.15625<br><br>


<b>Question:</b><br>
Represent 12.3125 as a 4.4 format number.
<br><Br>

<b>Answer:</b><br>
The most intuitive way to arrive at an answer is to represent 12.3125
as the sum of powers of 2.<br>
12.3125 = 2<sup>3</sup>+2<sup>2</sup>+2<sup>-3</sup>+2<sup>-4</sup>
=1100.0011 
<br>

While an intuitive route to the solution, this not the easiest way to
arrive at the solution, not by a long shot.  Let's explore an
alternative.<br><br>

Take the number 12.3125 and multiply it by 2<sup>4</sup> = 16.  This 
yields 12.3125 * 16 = 197.  Next represent 197 in binary yielding 
11000011.   Finally, to get back to our orginal value, we will divide
the binary form of 197 by 16 = 2<sup>4</sup>.  If we perform this operation
in binary, all we need to do is to shift the decimal point of the binary 
representation left by 4-bits.  This will yield 1100.0011, a 4.4 format 
number.<br><br>

In summary, to convert a decimal number D into a N.M format number:
<ol>	<li>Check that the integer part of D is less than 2<sup>N</sup>.
	If not, you cannot "fit" D into a N.M format number.
	<li>Multiply D and 2<sup>M</sup> to get B.
	<li>Round B to the closest integer.
	<li>Represent B in binary.
	<li>Divide B by 2<sup>M</sup> by shifting the decimal point
	in B M-bits to the left.
</ol>
Let's do an example to try this out.<br><br>

<b>Question:</b><br>
Determine the representation for 5.4375 as a 4.4 format number.
<br><br>

<b>Answer:</b> 
Since there are 4 bits to the right of the decimal point, we will
multiply 5.4375 * 2<sup>4</sup> = 87 = 01010111  In order to 
represent our original value, we need to shift the decimal point
left 4 bits yielding 0101.0111.
<br><br>


<b>Question:</b><br>
Assume a 16-bit fixed point representation in 6.10 notation.
Determine the representation for 5.44<br><br>

<b>Answer:</b> <br>
Since there are 10 bits to the right of the decimal point, we will
multiply 5.44 * 2<sup>10</sup> = 5571 = 0001 0101 1100 0011  In order to 
represent our original value, we need to shift the decimal point
left 10 bits yielding 000101.0111000011
<br><Br>


<h1>Test your understanding</h1>
You can find the solutions embedded in the "source code" for this
web page by right mouse clicking on this web page and selecting
"view source".  The solutions are in HTML comments.

<!--  This is an HTML comment -->

<ul>
<li>Given an update rate of 10us, a 64-entry ROM, what
phase increment would yield a 2kHz wave?


<!--
Start by observing that a 2kHz wave has a period of 500us.
<pre>
1 wave   1 update     X phase inc      1 wave      
------ = ---------- * ----------- * ------------ 
500us       10us      1 update      64 phase inc 
</pre>

Solving this equation gives us X = 1.28<br><Br>
-->


<li>Given an update rate of 25us, a phase increment of 0.35, and
a ROM with 16 entries, what is the frequency of the output waveform?

<!--
<pre>
1 update     10^6 us   0.35 phase inc      1 wave      
---------- * ------- * -------------- * ------------ = 875 Hz
  25us        1 sec       1 update      16 phase inc 
</pre>

-->


<li>What is the 3.5 format numbering representation of decimal 3.6?

<!--
Since we have 5 fractional bits we will multiply and divide by 
2<sup>5</sup> = 32.  3.6 * 32 = 115.2 which rounds to 115. 
115 in decimal is equivlent to 01110011 in binary. Dividing
01110011 by 32 yields 011.10011.  Represented as a 3.5 format
number 3.6 is 01110011
-->

<li>Interpret 01001101 as a  4.4 format number.

<!--
01001101 when interpreted as a 4.4 format number with a decimal
point looks like 0100.1101  The whole number portion is 0100 = 4.
The fractional portion is 2<sup>-1</sup> + 2<sup>-2</sup> + 2<sup>-4</sup>
= 0.8125.  Thus 01001101 interpreted as a 4.4 format number is 4.8125
-->


<li>Determine the representation of 5.4375 as a 3.5 format number. Also
calculate the error of this representation. 

<!--
Since there are 5 bits to the right of the decimal point, we will multiply 5.4375 * 32 = 174 = 0b10101110 In order to represent our original value, we need to shift the decimal point left 5 bits yielding 101.01110 = 5.4375. The error of this representation is 5.4375 - 5.4375 = 0
-->

<li>Determine the representation of 5.4375 as a 4.4 format number. Also
calculate the error of this representation. 

<!--
Since there are 4 bits to the right of the decimal point, we will multiply 5.4375 * 16 = 87 = 0b01010111 In order to represent our original value, we need to shift the decimal point left 4 bits yielding 0101.0111 = 5.4375. The error of this representation is 5.4375 - 5.4375 = 0
-->

<li>Determine the representation of 5.4375 as a 5.3 format number. Also
calculate the error of this representation. 

<!--
Since there are 3 bits to the right of the decimal point, we will multiply 5.4375 * 8 = 43.5 rounded = 44 = 0b00101100 In order to represent our original value, we need to shift the decimal point left 3 bits yielding 0000101.100 = 5.5.  The error of this representation is 5.5 - 5.4375 = 0.0625
-->

<li>Determine the representation of 5.4375 as a 6.2 format number. Also
calculate the error of this representation. 

<!--
Since there are 2 bits to the right of the decimal point, we will multiply 5.4375 * 4 = 21.75 rounded = 22 = 0b00010110 In order to represent our original value, we need to shift the decimal point left 2 bits yielding 0000101.10 = 5.5.  The error of this representation is 5.5 - 5.4375 = 0.0625
-->

<li>Determine the representation of 5.4375 as a 7.1 format number. Also
calculate the error of this representation. 

<!--
Since there is 1 bit to the right of the decimal point, we will multiply 5.4375 * 2 = 10.875 rounded = 11 = 0b00001011 In order to represent our original value, we need to shift the decimal point left 1 bits yielding 00000101.1 = 5.5. The error of this representation is 5.5 - 5.4375 = 0.0625
-->


<li>Determine the representation of 5.4375 as a 8.0 format number. Also
calculate the error of this representation.
<!--
Since there is 0 bit to the right of the decimal point, we will multiply 5.4375 * 1 = 5.4375 rounded = 5 = 0b00000101 In order to represent our original value, we need to shift the decimal point left 0 bits yielding 0000000101 = 5.  The error of this representation is 5 - 5.4375 = 0.4375
-->


<li>Compile the previous result into the following table, what is
the general trend in error as a function of the format?

<table class="table table-bordered table-condensed">
<tr><td>Format          <td>Binary      <td>Error
<tr><td>3.5             <td>&nbsp   	<td>&nbsp
<tr><td>4.4             <td>&nbsp   	<td>&nbsp
<tr><td>5.3             <td>&nbsp  	 <td>&nbsp
<tr><td>6.2             <td>&nbsp  	 <td>&nbsp
<tr><td>7.1             <td>&nbsp  	 <td>&nbsp
<tr><td>8.0             <td>&nbsp  	 <td>&nbsp
</table>


<!--
<table class="table table-bordered table-condensed">
<tr><td>Format          <td>Binary      <td>Error
<tr><td>3.5             <td>101.01110   <td>0.0
<tr><td>4.4             <td>0101.0111   <td>0.0
<tr><td>5.3             <td>00101.100   <td>0.0625
<tr><td>6.2             <td>000101.10   <td>0.0625
<tr><td>7.1             <td>0000101.1   <td>0.0625
<tr><td>8.0             <td>00000101.   <td>0.4375
</table>
As the number of fractional bits increases, the error decreases.
-->


</html>
